(* This file is part of DBL, released under MIT license.
 * See LICENSE for details.
 *)

import List

(* ========================================================================= *)

data Testing (effect AssertEff) =
	{ assert : String -> Bool ->[AssertEff] Unit
	, expect : String -> Bool ->[AssertEff] Unit
	}

method red {self : String} = "\027[31m" + self + "\027[0m"
method green {self : String} = "\027[32m" + self + "\027[0m"

let hTesting (f : {AssertEff, `testing: Testing AssertEff} -> Unit ->[AssertEff|_] Unit) =
	handle {effect=E_testing} testing = Testing 
		{ assert = effect msg b / r => fn st =>
			if b then r () st else (
				printStrLn ("Assertion failed".red + ": " + msg);
				False)
		, expect = effect msg b / r => fn st =>
			if b then r () st else (
				printStrLn ("Expectation failed".red + ": " + msg);
				r () False)
		}
		return () => fn x => x
		finally f => f True
		in
		let `testing = testing in
		f {AssertEff=E_testing, `testing} ()

(* ========================================================================= *)

data TestUnit = {
	name : String,
	body : Unit ->[|_] Unit
	(* TODO: add tags *)
	}

let makeUnit (name : String) (body : Unit ->[|_] Unit) =
	TestUnit{ name, body }

data TestingModule = TestingModule of
	{ name	: String
	, tests : List TestUnit
	(* TODO: add tags *)
}

method name {self = TestingModule{ name } : TestingModule} = name
method tests {self = TestingModule{ tests } : TestingModule} = tests

let makeModule  (name : String) =
	TestingModule{ name, tests = [] }

method updateModule {self : TestingModule} unit =
	TestingModule{ name = self.name, tests = unit :: self.tests }

data HeadModule (effect TestModSt) =
	{ getTests	 : Unit ->[TestModSt] List TestUnit
	, getModules : Unit ->[TestModSt] List TestingModule
	, setModules : List TestingModule ->[TestModSt] Unit
	, setTests	 : List TestUnit ->[TestModSt] Unit
	}

(* ========================================================================= *)
(* running tests *)

data TestingStats =
	{ modName : String
	, passed : List String
	, failed : List String
	}

method toString {self : TestingStats} =
	let passedLen = self.passed.length in
	let failedLen = self.failed.length in
	let total = passedLen + failedLen in
	let failed = if failedLen == 0 then ""
	else "failed:" + self.failed.foldLeft
		(fn (str : String) name => str + "\n" + name.red) "" in
	"module '" + self.modName
	+ "' [" + passedLen.toString + "/" + total.toString + "]\n"
	+ failed

let constTrue _ = True

method runTest {self : TestUnit}
		(TestingStats{ modName, passed, failed }) =
	if hTesting self.body
	then (
		printStrLn ("[PASSED]".green + ": " + self.name);
		TestingStats{ modName, passed = self.name :: passed, failed })
	else (
		printStrLn ("[FAILED]".red + ": " + self.name);
		TestingStats{ modName, passed, failed = self.name :: failed })

method runTests {self : TestingModule} =
	let stats = TestingStats{ modName=self.name, passed=[], failed=[] } in
	printStrLn ("=======[" + self.name + "]=======");
	let stats = self.tests.rev.foldLeft (fn stats t => t.runTest stats) stats in
	let passedLen = stats.passed.length in
	let failedLen = stats.failed.length in
	let total = passedLen + failedLen in
	printStrLn ("=======[" + passedLen.toString
		+ "/" + total.toString + "]=======");
	stats

let runHeadTests (tests : List TestUnit)
		(mods : List TestingModule) =
	(* TODO : add filtering of modules/tests based on argv *)
	let stats = TestingStats{ modName="head", passed=[], failed=[] } in
	let headResults = (tests.rev.foldLeft (fn stats t => t.runTest stats) stats)
	let results = headResults :: mods.rev.map (fn m => m.runTests) in
	let res = results.foldLeft (fn res s =>
		printStrLn s.toString;
		res && s.failed.isEmpty) True in
	if res
	then exit 0
	else exit 1


handle head_module = HeadModule
	{ getTests	 = effect () / r => fn st => r (fst st) st
	, getModules = effect () / r => fn st => r (snd st) st
	, setModules = effect mods / r => fn (tests, _) =>
		r () (tests, mods)
	, setTests	 = effect tests / r => fn (_, mods) =>
		r () (tests, mods)
	}
	return _ => fn (tests, mods) => runHeadTests tests mods
	finally head_module => head_module ([], [])

(* ========================================================================= *)
(* helpers in registering tests *)

data TestModule = { name : String }

method addTest {TestModSt, self : HeadModule TestModSt} test =
	let tests = head_module.getTests () in
	head_module.setTests (test :: tests)

method addModule {TestModSt, self : HeadModule TestModSt} mod =
	let mods = head_module.getModules () in
	head_module.setModules (mod :: mods)

method updateModule {TestModSt, self : HeadModule TestModSt} (mod : TestModule) test =
	let mods = head_module.getModules () in
	let rec aux (mods : List TestingModule) = match mods with
		| mod' :: mods =>
			if mod'.name == mod.name
			then mod'.updateModule test :: mods
			else mod' :: aux mods
		| [] =>
			// this should never occur, but if it does, nothing bad will happen
			[ makeModule mod.name >. updateModule test ]
		end in
	head_module.setModules (aux mods)

(* ========================================================================= *)
(* public interface for testing *)

implicit `testing {E_testing} : Testing E_testing

pub method assertNot
		{ AssertEff
		, self : Testing AssertEff
		, ?msg} (b : Bool) =
	let msg =
		match msg with
		| Some msg => msg
		| None     => ""
		end in
	self.assert msg (not b)

pub method assert
		{ AssertEff
		, self : Testing AssertEff
		, ?msg} =
	let msg =
		match msg with
		| Some msg => msg
		| None     => ""
		end in
	self.assert msg

pub method expectNot
		{ AssertEff
		, self : Testing AssertEff
		, ?msg} (b : Bool) =
	let msg =
		match msg with
		| Some msg => msg
		| None     => ""
		end in
	self.expect msg (not b)

pub method expect
		{ AssertEff
		, self : Testing AssertEff
		, ?msg} =
	let msg =
		match msg with
		| Some msg => msg
		| None     => ""
		end in
	self.expect msg

pub method name {self : TestModule} = self.name

pub let registerModule name =
	head_module.addModule (makeModule name);
	TestModule { name }

pub let registerTest name body =
	head_module.addTest (makeUnit name body)

pub method registerTest {self : TestModule} name body =
	head_module.updateModule self (makeUnit name body)

